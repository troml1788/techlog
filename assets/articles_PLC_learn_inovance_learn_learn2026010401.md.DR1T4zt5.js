import{_ as t,c as n,o,ae as l}from"./chunks/framework.PNVe5cA1.js";const r="/techlog/assets/image-2.Cw74JJdq.png",a="/techlog/assets/image-1.DEeOMsyb.png",g="/techlog/assets/image.BO6N2ITL.png",i="/techlog/assets/image-3.BvR_Vdcu.png",e="/techlog/assets/image-4.C_ufgVkS.png",p="/techlog/assets/image-6.BS4zdjUC.png",c="/techlog/assets/image-8.rDYZCfV1.png",u="/techlog/assets/image-9.CoX6LaDx.png",v=JSON.parse('{"title":"PLC的工作原理、扫描过程、双线圈冲突","description":"","frontmatter":{},"headers":[],"relativePath":"articles/PLC/learn/inovance/learn/learn2026010401.md","filePath":"articles/PLC/learn/inovance/learn/learn2026010401.md"}'),d={name:"articles/PLC/learn/inovance/learn/learn2026010401.md"};function h(m,s,C,_,P,L){return o(),n("div",null,[...s[0]||(s[0]=[l('<h1 id="plc的工作原理、扫描过程、双线圈冲突" tabindex="-1"><strong>PLC的工作原理、扫描过程、双线圈冲突</strong> <a class="header-anchor" href="#plc的工作原理、扫描过程、双线圈冲突" aria-label="Permalink to &quot;**PLC的工作原理、扫描过程、双线圈冲突**&quot;">​</a></h1><h2 id="plc工作原理" tabindex="-1">PLC工作原理 <a class="header-anchor" href="#plc工作原理" aria-label="Permalink to &quot;PLC工作原理&quot;">​</a></h2><blockquote><p><strong>核心：循环扫描</strong><img src="'+r+'" alt="alt text"></p></blockquote><p>PLC（可编程逻辑控制器）并非实时响应每一个输入信号，而是采用一种称为<strong>循环扫描</strong>的工作方式。它周而复始地执行一系列固定的步骤，形成一个循环，每个循环称为一个<strong>扫描周期</strong>。 <img src="'+a+'" alt="alt text"><strong>关键概念解释：</strong></p><ul><li><strong>流程：</strong> 指的就是上述的扫描周期，即从开始到结束所经历的全部步骤。</li><li><strong>输入映像（寄存器）：</strong> 这是PLC内部的一块内存区域。在扫描周期的开始阶段，PLC会<strong>一次性、批量地</strong>读取所有外部输入端子（如X0, X1）的物理状态（ON或OFF），然后将这些状态存入这个区域。可以把它理解为给所有输入信号拍了一张“快照”。在接下来的整个程序执行阶段，PLC都只使用这张“快照”中的数据，而不再关心外部输入点的实际变化，这保证了本周期内处理数据的稳定性。</li><li><strong>输出映像（寄存器）：</strong> 这也是PLC内部的一块内存区域，专门用于暂存程序运算后希望输出的结果。在程序执行阶段，所有对于外部输出点（如Y0, Y1）的控制命令都只是更新这个区域里的状态。直到扫描周期的最后，PLC才会将这个区域里的状态<strong>一次性、批量地</strong>复制到实际的物理输出端子上，驱动负载（如指示灯、继电器）动作。</li></ul><h2 id="plc工作过程" tabindex="-1"><strong>PLC工作过程</strong> <a class="header-anchor" href="#plc工作过程" aria-label="Permalink to &quot;**PLC工作过程**&quot;">​</a></h2><p><img src="'+g+'" alt="alt text"><strong>1. 输入与输出的关系</strong></p><ul><li><strong>核心结论：输入和输出之间没有直接的、必然的联系。</strong></li></ul><p><img src="'+i+'" alt="alt text"></p><ul><li>输入信号（如按钮按下）只是为PLC提供了原始数据。输出信号（如电机启动）是PLC内部的用户程序根据这些输入数据、结合自身的逻辑（如延时、计数等）进行运算后产生的结果。</li><li><strong>误区纠正：</strong> 不能认为“输入X0接通，输出Y0就一定接通”。Y0是否接通，完全取决于程序是如何编写的。PLC只是一个严格按程序执行的“执行者”。</li></ul><p><strong>2. 扫描三步骤</strong> 一个完整的扫描周期包含以下三个核心步骤：</p><ol><li><p><strong>输入采样（输入刷新）阶段：</strong></p><ul><li>PLC读取所有外部输入点的ON/OFF状态。</li><li>将这些状态全部存入<strong>输入映像寄存器</strong>。至此，输入映像寄存器就成为了本周期的“输入数据源”。</li></ul></li><li><p><strong>程序执行阶段：</strong></p><ul><li>这是PLC工作的核心。CPU会按照用户编写的程序（梯形图、指令表等），<strong>严格按照“从左到右，从上到下”的顺序</strong>进行扫描和运算。</li><li><strong>程序段扫描：</strong> 对于梯形图，遇到串联触点（与逻辑）就从左到右运算，遇到并联触点（或逻辑）就从上到下运算。每一步的运算结果会立刻影响到内部继电器、计时器、计数器和<strong>输出映像寄存器</strong>的状态。</li><li><strong>关键特性：</strong> 在此阶段，即使程序逻辑使<strong>输出映像寄存器</strong>的状态发生了变化，<strong>实际的物理输出点也不会立即动作</strong>。</li></ul></li><li><p><strong>输出刷新（输出更新）阶段：</strong></p><ul><li>当所有用户程序都执行完毕后，PLC将<strong>输出映像寄存器</strong>中存储的状态，<strong>一次性、全部地</strong>传送给实际的外部物理输出点。</li><li>只有到了这个阶段，外部设备（如马达、灯泡）才会真正根据程序逻辑开始动作。</li></ul></li></ol><p>完成以上三步后，PLC又回到第一步，开始下一个扫描周期，如此反复循环。</p><hr><h2 id="双线圈冲突" tabindex="-1">双线圈冲突 <a class="header-anchor" href="#双线圈冲突" aria-label="Permalink to &quot;双线圈冲突&quot;">​</a></h2><p><img src="'+e+'" alt="alt text"><strong>1. 什么是“双线圈冲突”？</strong></p><ul><li><strong>定义：</strong> 在同一个用户程序中，<strong>同一个输出线圈</strong>（例如Y0）被<strong>多次编程</strong>，出现在不同的网络段或位置。</li><li><strong>问题根源：</strong> 由于PLC扫描是<strong>顺序执行</strong>的，对于同一个线圈，<strong>后执行的程序会覆盖先执行程序的结果</strong>。</li><li><strong>后果：</strong> 最终输出线圈的状态<strong>只取决于程序中最后一次出现该线圈时的驱动条件</strong>，导致前面的逻辑完全失效，程序行为与设计预期严重不符，是常见的编程错误。</li></ul><p><strong>举个例子（对照课程中的例子理解）：</strong> 假设程序中有两处出现了Y0：</p><ul><li><strong>第一处：</strong> 当X0接通时，希望让Y0输出（ON）。</li><li><strong>第二处：</strong> 当X1接通时，希望让Y0输出（ON）。</li></ul><p>如果按照下图所示编程，就会发生冲突：（按下了X0,但是输出线圈并没有亮起） <img src="'+p+`" alt="alt text"></p><ul><li><strong>PLC的扫描执行过程：</strong><ol><li>扫描网络1：如果X0为ON，则把Y0的<strong>输出映像寄存器</strong>状态设为ON。</li><li>扫描网络2：如果X1为OFF，则把Y0的<strong>输出映像寄存器</strong>状态<strong>重新设为OFF</strong>。</li><li>进入输出刷新阶段：将Y0的最终状态OFF输出到物理端子，灯熄灭。</li></ol></li><li><strong>结果：</strong> 即使X0按钮按下，Y0的灯也不会亮，因为它的状态被后面X1=OFF的网络覆盖了。这就是“双线圈冲突”。</li></ul><p><strong>2. 如何解决“双线圈冲突”？</strong></p><p><strong>解决方案一：简化布尔逻辑（合并条件）</strong></p><ul><li><p><strong>原理：</strong> 将驱动同一个线圈的多个条件，通过“或”逻辑合并到<strong>一个线圈</strong>上。</p></li><li><p><strong>操作：</strong> 将上面例子中的两个网络合并成一个网络。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>        X0      X1</span></span>
<span class="line"><span>----||-------+-------( Y0 )</span></span>
<span class="line"><span>             |</span></span></code></pre></div></li><li><p><strong>解释：</strong> 这样Y0在程序中只出现了一次。只要X0 <strong>或</strong> X1任意一个为ON，Y0就会得电为ON。从根本上避免了覆盖问题。</p></li><li><p><strong>适用场景：</strong> 适用于驱动逻辑比较简单的情况。 <img src="`+c+`" alt="alt text"><strong>解决方案二：使用内部中间继电器（M点）—— 推荐方法</strong></p></li><li><p><strong>原理：</strong> 利用PLC内部的“虚拟”继电器（M点）作为中间变量，先存储各个分支的逻辑结果，最后再用这些中间结果来共同驱动最终的输出线圈。</p></li><li><p><strong>操作（两步法）：</strong></p><ol><li><strong>分支暂存：</strong> 将不同的驱动条件输出到不同的M点。<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>网络1： X0 ---- ( M0 )  //X0接通，则M0为ON</span></span>
<span class="line"><span>网络2： X1 ---- ( M1 )  //X1接通，则M1为ON</span></span></code></pre></div></li><li><strong>集中驱动：</strong> 用所有相关的M点的触点，来驱动唯一的Y0线圈。<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>网络3： M0      M1</span></span>
<span class="line"><span>----||-------+-------( Y0 )</span></span>
<span class="line"><span>             |</span></span></code></pre></div></li></ol></li><li><p><strong>优点：</strong></p><ul><li><strong>彻底解决冲突：</strong> Y0只被驱动一次，状态不会被覆盖。</li><li><strong>程序清晰易读：</strong> 逻辑分明，易于后期维护和调试。</li><li><strong>灵活性强：</strong> M点的状态还可以用于其他地方（如<strong>触摸屏显示、其他逻辑判断</strong>）。</li></ul></li><li><p><strong>适用场景：</strong> 尤其适用于逻辑复杂、分支多的场合，是工程中的标准做法。 <img src="`+u+'" alt="alt text"><strong>总结：</strong> 解决双线圈冲突的核心就是遵循 <strong>“一个输出线圈，在程序中只被驱动一次”</strong> 的原则。</p></li></ul>',24)])])}const x=t(d,[["render",h]]);export{v as __pageData,x as default};
